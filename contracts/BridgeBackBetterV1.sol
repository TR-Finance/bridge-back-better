// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

/**
 * @title Contract allowing users to bridge assets from Arbitrum to mainnet faster by selling their withdrawals.
 * @author Theo Ilie
 */
contract BridgeBackBetterV1 {
    uint256 COOLDOWN_PERIOD = 7 days;

    struct ValidWithdrawalClaim {
        uint256 amount; // In wei
        uint256 withdrawalId; // The ID generated by Arbitrum
        uint256 timestampToSlashAt; // The block after which the user can be slashed for the pool not receiving a valid withdrawal
    }

    struct Delegator {
        uint256 balance;
        uint256 timestampUnlocked; // The block after which the delegator can withdraw their balance
    }

    struct NodeOperator {
        bool paused;
        uint256 bondedBalance; // In wei
        uint256 timestampUnlocked; // The block after which the node operator can withdraw their bond
        uint256 delegatedBalance; // In wei
        mapping(address => Delegator) delegators;
        ValidWithdrawalClaim[] withdrawalClaims;
    }

    address public owner;
    mapping(address => NodeOperator) public nodeOperators;
    uint256 public totalAvailableBonded; // Total bonded that's not slashed or locked
    uint256 public totalAvailableDelegated; // Total stake delegated that's not slashed or locked
    uint256 public stakerFee; // In wei
    uint256 public nodeOperatorFee; // In wei

    modifier onlyOwner() {
        require(msg.sender == owner, 'Only the contract owner can do this');
        _;
    }

    constructor(uint256 _stakerFee, uint256 _nodeOperatorFee) {
        owner = msg.sender;
        stakerFee = _stakerFee;
        nodeOperatorFee = _nodeOperatorFee;
    }

    function setStakerFee(uint256 _stakerFee) external onlyOwner {
        stakerFee = _stakerFee;
    }

    function setNodeOperatorFee(uint256 _nodeOperatorFee) external onlyOwner {
        nodeOperatorFee = _nodeOperatorFee;
    }

    /**
     * Allow node operator to join the network by putting up collateral (ETH).
     * @notice The ether sent here can't be withdrawn for 7 days.
     */
    function bond() external payable {
        nodeOperators[msg.sender].paused = false;
        nodeOperators[msg.sender].bondedBalance += msg.value;
        nodeOperators[msg.sender].timestampUnlocked = block.timestamp + COOLDOWN_PERIOD;
        totalAvailableBonded += msg.value;
    }

    /**
     * Unbond the full amount that the sending address currently has.
     * @notice You must have no outstanding withdrawal claims (call `claimWithdrawals`) and make sure you're not running your script.
     */
    function unbond() external {
        NodeOperator storage nodeOperator = nodeOperators[msg.sender];

        require(nodeOperator.withdrawalClaims.length == 0, 'Must have no claims');

        nodeOperators[msg.sender].paused = true;
        uint256 amount = nodeOperator.bondedBalance;
        nodeOperator.bondedBalance = 0;
        totalAvailableBonded -= amount;

        (bool success, ) = msg.sender.call{value: amount}('');
        require(success, 'Unbonding failed');
    }

    /**
     * Delegate ether to a node operator to share in their rewards.
     * @notice The ether sent here can't be withdrawn for 7 days.
     *         Node operators can steal funds if they have more ether delegated than bonded.
     * @param nodeOperator The address of the node operator to delegate ether to
     */
    function delegate(address nodeOperator) external payable {
        // TODO
    }

    function undelegate(address nodeOperator) external {
        // TODO
    }

    /**
     * Verify that a withdrawal is valid and claim a fee.
     * Only callable by node operators with a high enough bond to cover losses.
     * @dev If `withdrawId` doesn't add `amount` to the pool within 7 days then the bonder will be slashed.
     * @param recipient The address that should receive the funds
     * @param amount The amount that the recipient should receive
     * @param withdrawalId The ID that was generated on Arbitrum and will be passed with a valid transaction in 7 days
     */
    function verifyWithdrawal(
        address recipient,
        uint256 amount,
        uint256 withdrawalId
    ) external {
        NodeOperator storage nodeOperator = nodeOperators[msg.sender];
        // Node operator must have enough delegated to provide an advance on the withdrawal
        require(nodeOperator.delegatedBalance >= amount, 'Not enough delegated');

        // Take the money from the node operator's delegated amount first
        nodeOperator.delegatedBalance -= amount;

        // Send the recipient the money for their withdraw (minus fees)
        (bool success, ) = recipient.call{value: amount - nodeOperatorFee - stakerFee}('');
        require(success, 'Transfer failed');

        // TODO: Add fee accounting separately for node operator and its delegators

        // Update the node operator's delegated balance and the contract's balance
        nodeOperator.lockedDelegatedBalance += amount;
        totalAvailableDelegated -= amount;

        // Add a claim saying that there will be a withdrawal with the ID 'withdrawalId' after
        // the challenge period (7 days) or else the node operator's bond will be slashed
        nodeOperator.withdrawalClaims.push(
            ValidWithdrawalClaim(amount, withdrawalId, block.timestamp + COOLDOWN_PERIOD)
        );
    }
}
